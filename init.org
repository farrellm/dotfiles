#+TITLE: Emacs init file written in org-mode
#+AUTHOR: Matthew Farrell
#+EMAIL: farrellm@alum.mit.edu

* basic ui
** common
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

** window only
#+BEGIN_SRC emacs-lisp
  (when window-system
    (blink-cursor-mode 0)
    (setq-default cursor-type 'bar)

    (add-hook 'after-init-hook
              (lambda ()
                (load-theme 'zenburn))))
#+END_SRC

** It's annoying to have to type 'yes' to answer questions. One letter is enough for confirmation.
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Ido, which is short for "Interactively Do Things," is an amazingly efficient way to select files and switch buffers.
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
#+END_SRC

** auto-revert buffers
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
** parenthesis highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (set-face-foreground 'show-paren-match "white")
#+END_SRC
** follow symlinks to version controlled files
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks nil)
#+END_SRC
** global keybindings
#+BEGIN_SRC emacs-lisp
  (defun prev-window ()
    "previous window"
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x p") 'prev-window)
  (global-set-key (kbd "C-x x") 'execute-extended-command)
  (global-set-key (kbd "C-X C-b") 'ibuffer)
  (global-set-key (kbd "C-X g") 'goto-line)
  (global-set-key (kbd "C-;") 'comment-or-uncomment-region)
#+END_SRC
* packages
** auto-complete
#+BEGIN_SRC emacs-lisp
  (defvar ac-ignore-case nil)

  (add-hook 'after-init-hook
            (lambda ()
              (require 'auto-complete)
              (require 'auto-complete-config)

              (ac-config-default)
              (ac-flyspell-workaround)

              ;; (add-to-list 'ac-modes 'org-mode)
              ))
#+END_SRC
** org
*** auto-complete
#+BEGIN_SRC emacs-lisp
  ;; (eval-after-load "org"
  ;;   '(progn
  ;;      (require 'org-ac)
  ;;      (org-ac/config-default)))
#+END_SRC
*** export
#+BEGIN_SRC emacs-lisp
  (defvar org-export-allow-bind-keywords t)
#+END_SRC
*** babel
**** misc
#+BEGIN_SRC emacs-lisp
  (defvar org-startup-indented t)
  (defvar org-src-fontify-natively t)
#+END_SRC
**** disable evaluation confirmations
#+BEGIN_SRC emacs-lisp
  (defvar org-confirm-babel-evaluate nil)
#+END_SRC
**** inline images
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)   
  (add-hook 'org-mode-hook 'org-display-inline-images)
#+END_SRC
**** load languages
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/home/mfarrell/.emacs.d/ob-julia")
  (eval-after-load "org"
    '(progn
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (haskell . t)
          (julia . t)
          (R . t)))))
#+END_SRC

** cider
*** keybindings
#+BEGIN_SRC emacs-lisp
  (defun count-last-sexp ()
         (interactive)
         (cider-interactive-eval
           (format "(count %s)"
                   (cider-last-sexp))))

  (defun nth-from-last-sexp (n)
         (interactive "p")
         (cider-interactive-eval
           (format "(nth %s %s)"
                   (cider-last-sexp) n)))

  (defun spit-scad-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format    
        "(require 'scad-clj.scad)
         (spit \"eval.scad\" (scad-clj.scad/write-scad %s))"
        (cider-last-sexp))))

  (defun frame-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format    
       "(doto (javax.swing.JFrame. \"eval\")
          (.. (getContentPane) (add %s))
          (.pack)
          (.show))"
       (cider-last-sexp))))

  (defun benchmark-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format "(require 'criterium.core)
               (criterium.core/quick-benchmark %s)"
              (cider-last-sexp))))

  (eval-after-load "cider"
    '(progn
       (define-key cider-mode-map (kbd "C-c c") 'count-last-sexp)
       (define-key cider-mode-map (kbd "C-c n") `nth-from-last-sexp)
       (define-key cider-mode-map (kbd "C-c 3") 'spit-scad-last-sexp)
       (define-key cider-mode-map (kbd "C-c f") 'frame-last-sexp)
       (define-key cider-mode-map (kbd "C-c b") 'benchmark-last-sexp)))
#+END_SRC
** ESS
*** load
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/home/mfarrell/.emacs.d/ESS/lisp/")
  (require 'ess-site)
#+END_SRC
*** julia
#+BEGIN_SRC emacs-lisp
  (setq inferior-julia-program-name "/home/mfarrell/bin/julia")
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC
** haskell
#+BEGIN_SRC emacs-lisp
  ;;; https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

  ;;; haskell-mode
  (setenv "PATH" (concat "~/.cabal/bin:" (getenv "PATH")))
  (add-to-list 'exec-path "~/.cabal/bin")
  (custom-set-variables '(haskell-tags-on-save t))

  (custom-set-variables
    '(haskell-process-suggest-remove-import-lines t)
    '(haskell-process-auto-import-loaded-modules t)
    '(haskell-process-log t))
  (eval-after-load 'haskell-mode '(progn
    (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
    (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
    (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
    (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
    (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
    (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)
    (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)))
  (eval-after-load 'haskell-cabal '(progn
    (define-key haskell-cabal-mode-map (kbd "C-`") 'haskell-interactive-bring)
    (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-ode-clear)
    (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
    (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))

  (custom-set-variables '(haskell-process-type 'cabal-repl))

  ;;; ghc-mod
  ;; (autoload 'ghc-init "ghc" nil t)
  ;; (autoload 'ghc-debug "ghc" nil t)
  ;; (add-hook 'haskell-mode-hook (lambda () (ghc-init)))

  ;;; company
  (add-hook 'haskell-mode-hook 'company-mode)
  (custom-set-variables '(company-ghc-show-info t))
  (eval-after-load "company"
    '(progn
       (add-to-list 'company-backends 'company-ghc)))

  (defvar haskell-font-lock-symbols t)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc)
  ;; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
  (add-hook 'haskell-mode-hook 'structured-haskell-mode)

  (eval-after-load 'haskell-mode
    '(define-key haskell-mode-map [f8] 'haskell-navigate-imports))

  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
#+END_SRC
** smartparens
   https://github.com/Fuco1/smartparens/wiki/Example-configuration
#+BEGIN_SRC emacs-lisp
  (eval-after-load "smartparens-autoloads"
    '(progn
       (require 'smartparens-config)
       (smartparens-global-mode t)
       (smartparens-global-strict-mode t)

       ;; highlights matching pairs
       (show-smartparens-global-mode t)

       ;; keybinding management
       (sp-use-smartparens-bindings)

       ;; pair management
       (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

       ;; markdown-mode
       (sp-with-modes '(markdown-mode gfm-mode rst-mode)
         (sp-local-pair "*" "*" :bind "C-*")
         (sp-local-tag "2" "**" "**")
         (sp-local-tag "s" "```scheme" "```")
         (sp-local-tag "<" "<_>" "</_>" :transform 'sp-match-sgml-tags))

       ;; tex-mode latex-mode
       (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
         (sp-local-tag "i" "\"<" "\">"))

       ;; html-mode
       (sp-with-modes '(html-mode sgml-mode)
         (sp-local-pair "<" ">"))

       ;; lisp modes
       (sp-with-modes sp--lisp-modes
         (sp-local-pair "(" nil :bind "C-("))

       (require 'smartparens-latex)
       ))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  ;;; keybinding management
  (eval-after-load "smartparens-autoloads"
    '(progn
       (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
       (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)

       (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
       (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
       ;; (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
       ;; (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

       (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
       (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
       (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
       (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

       (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
       (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

       (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
       (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

       (define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
       (define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

       (define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
       (define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
       (define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
       (define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

       (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
       (define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
       (define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
       (define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

       (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
       (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
       (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)

       (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
       (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)

       (define-key sp-keymap (kbd "s-t") 'sp-prefix-tag-object)
       (define-key sp-keymap (kbd "s-p") 'sp-prefix-pair-object)
       (define-key sp-keymap (kbd "s-s c") 'sp-convolute-sexp)
       (define-key sp-keymap (kbd "s-s a") 'sp-absorb-sexp)
       (define-key sp-keymap (kbd "s-s e") 'sp-emit-sexp)
       (define-key sp-keymap (kbd "s-s p") 'sp-add-to-previous-sexp)
       (define-key sp-keymap (kbd "s-s n") 'sp-add-to-next-sexp)
       (define-key sp-keymap (kbd "s-s j") 'sp-join-sexp)
       (define-key sp-keymap (kbd "s-s s") 'sp-split-sexp)))
#+END_SRC
* package management
#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
  ;; (add-to-list 'package-archives '("melpa-stable" . "http://melpa-stable.milkbox.net/packages/") t)
#+END_SRC

* miscellaneous
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard-manager nil)
#+END_SRC

* customization
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(org-file-apps (quote ((auto-mode . emacs) ("\\.mm\\'" . default) ("\\.x?html?\\'" . default) ("\\.pdf\\'" . "evince %s"))))
   '(org-latex-pdf-process (quote ("pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f"))))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   )
#+END_SRC
