#+TITLE: Emacs init file written in org-mode
#+AUTHOR: Matthew Farrell
#+EMAIL: farrellm@alum.mit.edu

* package management
#+BEGIN_SRC emacs-lisp
  (require 'package)
  ;; (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives '("melpa-stable" . "http://melpa-stable.milkbox.net/packages/") t)

  (setq package-pinned-packages
        '((aggressive-indent . "melpa-stable")

          (auctex . "gnu")

          (company . "gnu")
          (company-ghc . "melpa-stable")
          (company-cabal . "melpa-stable")
          (company-go . "melpa-stable")

          (cider . "melpa-stable")
          (clojure-mode . "melpa-stable")
          (clojure-snippets . "melpa-stable")
          (typed-clojure-mode . "melpa-stable")

          (clojure-cheatsheet . "melpa-stable")
          (helm . "melpa-stable")
          (async . "melpa-stable")

          (clj-refactor . "melpa-stable")
          (edn . "melpa-stable")
          (helm-core . "melpa-stable")
          (paredit . "melpa-stable")
          (peg . "melpa-stable")
          (multiple-cursors . "melpa-stable")
          (s . "melpa-stable")

          (evil . "melpa-stable")
          (undo-tree . "gnu")
          (goto-last-change . "melpa-stable")

          (flycheck . "melpa-stable")
          (pkg-info . "melpa-stable")
          ;; (dash . "melpa-stable")
          (epl . "melpa-stable")
          (popup . "melpa-stable")

          ;; (flycheck-clojure . "melpa-stable")
          (flycheck-haskell . "melpa-stable")

          (ghc . "melpa-stable")
          (haskell-mode . "melpa-stable")
          (idris-mode . "melpa-stable")
          (rainbow-delimiters . "melpa-stable")
          (shm . "melpa-stable")

          (ido-ubiquitous . "melpa-stable")
          (ido-completing-read+ . "melpa-stable")
          (smex . "melpa-stable")

          (magit . "melpa-stable")
          (git-commit . "melpa-stable")
          (magit-popup . "melpa-stable")
          (with-editor . "melpa-stable")

          (markdown-mode . "melpa-stable")

          (smartparens . "melpa-stable")
          (dash . "melpa-stable")

          (scala-mode2 . "melpa-stable")
          (scala-outline-popup . "melpa-stable")

          (stan-mode . "melpa-stable")
          (stan-snippets . "melpa-stable")
          (auto-complete . "melpa-stable")

          (zenburn-theme . "melpa-stable")

          ;; company-coq
          (yasnippet . "melpa-stable")

          ;; company-ess
          (ess . "melpa-stable")
          (julia-mode . "melpa-stable")

          ;; 4clojure
          (request . "melpa-stable")))
#+END_SRC

* basic ui
** common
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

** window only
#+BEGIN_SRC emacs-lisp
  (when window-system
    (blink-cursor-mode 0)
    (setq-default cursor-type 'bar)

    (add-hook 'after-init-hook
              (lambda ()
                (load-theme 'zenburn))))
#+END_SRC

** console only
#+BEGIN_SRC emacs-lisp
  (unless window-system
    (add-hook 'after-init-hook
              (lambda ()
                (evil-mode 1)
                (define-key evil-insert-state-map (kbd "M-x") 'execute-extended-command))))
#+END_SRC

** It's annoying to have to type 'yes' to answer questions. One letter is enough for confirmation.
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Ido, which is short for "Interactively Do Things," is an amazingly efficient way to select files and switch buffers.
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
  (ido-everywhere t)
#+END_SRC

** auto-revert buffers
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
** parenthesis highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (set-face-foreground 'show-paren-match "white")
#+END_SRC
** follow symlinks to version controlled files
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks nil)
#+END_SRC
** global keybindings
#+BEGIN_SRC emacs-lisp
  (defun prev-window ()
    "previous window"
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x p") 'prev-window)
  (global-set-key (kbd "C-x x") 'smex)
  (global-set-key (kbd "C-X C-b") 'ibuffer)
  (global-set-key (kbd "C-X g") 'goto-line)
  (global-set-key (kbd "C-;") 'comment-or-uncomment-region)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  ;; This is your old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)

  (global-set-key (kbd "C-<tab>") 'company-complete-common-or-cycle)
#+END_SRC
** whitespace
#+BEGIN_SRC emacs-lisp
  (setq indent-tabs-mode nil)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** backups
https://www.emacswiki.org/emacs/BackupDirectory
#+BEGIN_SRC emacs-lisp
  (setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
   '(("." . "~/.saves"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+END_SRC

* packages
** auctex
Annoying, but seems to be needed since 24.4
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/elpa/auctex-11.89")
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  ;; (setq company-tooltip-align-annotations t)
#+END_SRC
** org
*** misc
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC
*** export
#+BEGIN_SRC emacs-lisp
  (defvar org-export-allow-bind-keywords t)
#+END_SRC
*** babel
**** misc
#+BEGIN_SRC emacs-lisp
  (defvar org-startup-indented t)
  (defvar org-src-fontify-natively t)

  (defun org-babel-invalidate-results ()
    "invalidated all cached babel results"
    (interactive)
    (while (re-search-forward "#\\+RESULTS\\[[[:alnum:]]+\\]" nil t)
      (replace-match "#+RESULTS[]" nil nil)))
#+END_SRC
**** disable evaluation confirmations
#+BEGIN_SRC emacs-lisp
  (defvar org-confirm-babel-evaluate nil)
#+END_SRC
**** inline images
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
  (add-hook 'org-mode-hook 'org-display-inline-images)
#+END_SRC
**** load languages
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/ob-julia")
  (eval-after-load "org"
    '(progn
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
          (haskell . t)
          (julia . t)
          (R . t)))))
#+END_SRC

** cider
*** basic configuration
**** Enable eldoc in Clojure buffers
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-mode-hook #'eldoc-mode)
#+END_SRC
**** Log communication with the nREPL server
#+BEGIN_SRC emacs-lisp
  (setq nrepl-log-messages t)
  (setq nrepl-hide-special-buffers t)
#+END_SRC
**** Prevent the auto-display of the REPL buffer
#+BEGIN_SRC emacs-lisp
  (setq cider-repl-pop-to-buffer-on-connect nil)
#+END_SRC

**** SOT mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook #'abbrev-mode)
  (add-hook 'clojure-mode-hook #'speed-of-thought-mode)
#+END_SRC

**** parens
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/elpa/adjust-parens-3.0")
  (require 'adjust-parens)

  (add-hook 'clojure-mode-hook #'adjust-parens-mode)
  (add-hook 'emacs-lisp-mode-hook #'adjust-parens-mode)

  (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
  (add-hook 'groovy-mode-hook #'aggressive-indent-mode)

  ;; nice, but has caused problems
  ;; (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
#+END_SRC

*** keybindings
#+BEGIN_SRC emacs-lisp
  (defun count-last-sexp ()
         (interactive)
         (cider-interactive-eval
           (format "(count %s)"
                   (cider-last-sexp))))

  (defun nth-from-last-sexp (n)
         (interactive "p")
         (cider-interactive-eval
           (format "(nth %s %s)"
                   (cider-last-sexp) n)))

  (defun spit-scad-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format
        "(require 'scad-clj.scad)
         (spit \"eval.scad\" (scad-clj.scad/write-scad %s))"
        (cider-last-sexp))))

  (defun frame-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format
       "(doto (javax.swing.JFrame. \"eval\")
          (.. (getContentPane) (add %s))
          (.pack)
          (.show))"
       (cider-last-sexp))))

  (defun benchmark-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format "(require 'criterium.core)
               (criterium.core/quick-benchmark %s)"
              (cider-last-sexp))))

  (eval-after-load "cider"
    '(progn
       (define-key cider-mode-map (kbd "C-c c") 'count-last-sexp)
       (define-key cider-mode-map (kbd "C-c n") `nth-from-last-sexp)
       (define-key cider-mode-map (kbd "C-c 3") 'spit-scad-last-sexp)
       (define-key cider-mode-map (kbd "C-c f") 'frame-last-sexp)
       (define-key cider-mode-map (kbd "C-c b") 'benchmark-last-sexp)))
#+END_SRC
*** misc
#+BEGIN_SRC emacs-lisp
  (defvar clojure-defun-indents '(match resize translate rotate scale mirror))
  ;; (add-hook 'clojure-mode-hook 'typed-clojure-mode)

  ;; (eval-after-load 'flycheck '(flycheck-clojure-setup))
  ;; (eval-after-load 'flycheck
  ;;   '(setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages))

  ;; (add-hook 'clojure-mode-hook (lambda ()
  ;;                                (clj-refactor-mode 1)))
#+END_SRC
** ESS
*** autoload
#+BEGIN_SRC emacs-lisp
  (autoload 'R-mode "ess-site" "Major mode for editing R source.
  See `ess-mode' for more help." t)
  (add-to-list 'auto-mode-alist '("\\.R\\'" . R-mode))
#+END_SRC
*** julia
#+BEGIN_SRC emacs-lisp
  (setq inferior-julia-program-name "/usr/bin/julia")
#+END_SRC
*** R
#+BEGIN_SRC emacs-lisp
  (add-hook 'R-mode-hook 'flycheck-mode)

  ;; From Martin Maechler <maechler at stat.math.ethz.ch>:
  (eval-after-load "comint"
    '(progn
       (setq comint-scroll-to-bottom-on-output 'others)   ; not current, dflt is nil
       ;; (setq comint-scroll-show-maximum-output t)      ; I find this too jumpy
       (define-key comint-mode-map [up]
         'comint-previous-matching-input-from-input)
       (define-key comint-mode-map [down]
         'comint-next-matching-input-from-input)
       (define-key comint-mode-map "\C-a" 'comint-bol-or-process-mark)))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC
** haskell
#+BEGIN_SRC emacs-lisp
  ;;; https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md

  ;;; haskell-mode
  (custom-set-variables '(haskell-tags-on-save t))

  (custom-set-variables
    '(haskell-process-suggest-remove-import-lines t)
    '(haskell-process-auto-import-loaded-modules t)
    '(haskell-process-log t))
  (eval-after-load 'haskell-mode '(progn
    (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-file)
    (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
    (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
    (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
    (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
    (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
  (eval-after-load 'haskell-cabal '(progn
    (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
    (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
    (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
    (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))

  (custom-set-variables '(haskell-process-type 'stack-ghci))

  ;;; ghc-mod
  (autoload 'ghc-init "ghc" nil t)
  (autoload 'ghc-debug "ghc" nil t)
  (add-hook 'haskell-mode-hook #'ghc-init)
  (setq ghc-report-errors nil)

  ;;; Company
  (custom-set-variables '(company-ghc-show-info t))
  (eval-after-load "company"
    '(add-to-list 'company-backends 'company-ghc))

  ;; (defvar haskell-font-lock-symbols t)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
  ;; (add-hook 'haskell-mode-hook 'structured-haskell-mode)

  (eval-after-load 'haskell-mode
    '(define-key haskell-mode-map [f8] 'haskell-navigate-imports))

  ;; flycheck
  (add-hook 'haskell-mode-hook #'flycheck-haskell-setup)
  (add-hook 'haskell-mode-hook #'flycheck-mode)
#+END_SRC
** rust
#+BEGIN_SRC emacs-lisp
  ;; flycheck
  (eval-after-load 'rust-mode '(require 'cl))
  (add-hook 'rust-mode-hook #'flycheck-rust-setup)
  (add-hook 'rust-mode-hook #'flycheck-mode)

  ;; racer
  (setq racer-rust-src-path "/usr/src/rust/src/")
  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)
#+END_SRC
** smartparens
   https://github.com/Fuco1/smartparens/wiki/Example-configuration
#+BEGIN_SRC emacs-lisp
  (eval-after-load "smartparens-autoloads"
    '(progn
       (require 'smartparens-config)
       (smartparens-global-mode t)
       (smartparens-global-strict-mode t)

       ;; highlights matching pairs
       (show-smartparens-global-mode t)

       ;; keybinding management
       (sp-use-smartparens-bindings)

       ;; pair management
       (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

       ;; markdown-mode
       (sp-with-modes '(markdown-mode gfm-mode rst-mode)
         (sp-local-pair "*" "*" :bind "C-*")
         (sp-local-tag "2" "**" "**")
         (sp-local-tag "s" "```scheme" "```")
         (sp-local-tag "<" "<_>" "</_>" :transform 'sp-match-sgml-tags))

       ;; tex-mode latex-mode
       (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
         (sp-local-tag "i" "\"<" "\">"))

       ;; html-mode
       (sp-with-modes '(html-mode sgml-mode)
         (sp-local-pair "<" ">"))

       ;; lisp modes
       (sp-with-modes sp--lisp-modes
         (sp-local-pair "(" nil :bind "C-("))

       (require 'smartparens-latex)
       ))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  ;;; keybinding management
  (eval-after-load "smartparens-autoloads"
    '(progn
       (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
       (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)

       (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
       (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
       ;; (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
       ;; (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

       (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
       (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
       (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
       (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

       (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
       (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

       (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
       (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

       (define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
       (define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

       (define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
       (define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
       (define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
       (define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

       (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
       (define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
       (define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
       (define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

       (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
       (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
       (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)

       (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
       (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)

       (define-key sp-keymap (kbd "s-t") 'sp-prefix-tag-object)
       (define-key sp-keymap (kbd "s-p") 'sp-prefix-pair-object)
       (define-key sp-keymap (kbd "s-s c") 'sp-convolute-sexp)
       (define-key sp-keymap (kbd "s-s a") 'sp-absorb-sexp)
       (define-key sp-keymap (kbd "s-s e") 'sp-emit-sexp)
       (define-key sp-keymap (kbd "s-s p") 'sp-add-to-previous-sexp)
       (define-key sp-keymap (kbd "s-s n") 'sp-add-to-next-sexp)
       (define-key sp-keymap (kbd "s-s j") 'sp-join-sexp)
       (define-key sp-keymap (kbd "s-s s") 'sp-split-sexp)))
#+END_SRC
* miscellaneous
** local
#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~/.emacs.d/local.el")
    (load "~/.emacs.d/local"))
#+END_SRC

** bug fix
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard-manager nil)
#+END_SRC

* customization
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(org-file-apps (quote ((auto-mode . emacs) ("\\.mm\\'" . default) ("\\.x?html?\\'" . default) ("\\.pdf\\'" . "evince %s"))))
   '(org-latex-pdf-process (quote ("pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f"))))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   )
#+END_SRC
