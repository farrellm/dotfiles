#+TITLE: Emacs init file written in org-mode
#+AUTHOR: Matthew Farrell
#+EMAIL: farrellm@alum.mit.edu

* package management
#+BEGIN_SRC emacs-lisp
  (require 'package)
  ;; (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)

  (setq package-selected-packages
	'(adjust-parens
          aggressive-indent
          company
          evil
          evil-leader
          evil-org
          evil-smartparens
          flycheck
          ido-ubiquitous
          magit
          org
          rainbow-delimiters
          smartparens
          smex

          auctex
          cider
          ensime
          ess
          fish-mode
          groovy-mode
          hindent
          idris-mode
          intero
          julia-mode

          color-theme-sanityinc-tomorrow
          zenburn-theme))

  (setq package-pinned-packages
	'((aggressive-indent . "melpa-stable")

          (auctex . "gnu")

          (company . "gnu")
          (company-ghc . "melpa-stable")
          (company-cabal . "melpa-stable")
          (company-go . "melpa-stable")

          (cider . "melpa-stable")
          (clojure-mode . "melpa-stable")
          (clojure-snippets . "melpa-stable")
          (typed-clojure-mode . "melpa-stable")

          (clojure-cheatsheet . "melpa-stable")
          (helm . "melpa-stable")
          (async . "melpa-stable")

          (clj-refactor . "melpa-stable")
          (edn . "melpa-stable")
          (helm-core . "melpa-stable")
          (paredit . "melpa-stable")
          (peg . "melpa-stable")
          (multiple-cursors . "melpa-stable")
          (s . "melpa-stable")

          (evil . "melpa-stable")
          (undo-tree . "gnu")
          (goto-last-change . "melpa-stable")
          (evil-org . "melpa-stable")
          (evil-leader . "melpa-stable")
          (evil-smartparens . "melpa-stable")

          (flycheck . "melpa-stable")
          (pkg-info . "melpa-stable")
          ;; (dash . "melpa-stable")
          (epl . "melpa-stable")
          (popup . "melpa-stable")

          ;; (flycheck-clojure . "melpa-stable")
          (flycheck-haskell . "melpa-stable")

          (ghc . "melpa-stable")
          ;; (haskell-mode . "melpa-stable")
          (hindent-mode . "melpa-stable")
          (idris-mode . "melpa-stable")
          (rainbow-delimiters . "melpa-stable")
          (shm . "melpa-stable")

          (ido-ubiquitous . "melpa-stable")
          (ido-completing-read+ . "melpa-stable")
          (smex . "melpa-stable")

          (magit . "melpa-stable")
          (git-commit . "melpa-stable")
          (magit-popup . "melpa-stable")
          (with-editor . "melpa-stable")

          (markdown-mode . "melpa-stable")

          (smartparens . "melpa-stable")
          (dash . "melpa-stable")

          (scala-mode2 . "melpa-stable")
          (scala-outline-popup . "melpa-stable")

          (stan-mode . "melpa-stable")
          (stan-snippets . "melpa-stable")
          (auto-complete . "melpa-stable")

          (color-theme-sanityinc-tomorrow . "melpa-stable")
          (zenburn-theme . "melpa-stable")

          ;; company-coq
          (yasnippet . "melpa-stable")

          ;; company-ess
          (ess . "melpa-stable")
          (julia-mode . "melpa-stable")

          ;; 4clojure
          (request . "melpa-stable")))
#+END_SRC

* basic ui
** common
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (setq ad-redefinition-action 'accept)

  (add-hook 'after-init-hook
	    (lambda () (load-theme 'sanityinc-tomorrow-night)))
#+END_SRC

** window only
#+BEGIN_SRC emacs-lisp
  (when window-system
    (blink-cursor-mode 0)
    (setq-default cursor-type 'bar))
#+END_SRC

** console only
#+BEGIN_SRC emacs-lisp
  (unless window-system
    (add-hook 'after-init-hook
              (lambda ()
                (evil-mode 1)
                (define-key evil-insert-state-map (kbd "M-x") 'execute-extended-command))))
#+END_SRC

** It's annoying to have to type 'yes' to answer questions. One letter is enough for confirmation.
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Ido, which is short for "Interactively Do Things," is an amazingly efficient way to select files and switch buffers.
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
  (ido-everywhere t)
#+END_SRC

** auto-revert buffers
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
** parenthesis highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (set-face-foreground 'show-paren-match "white")
#+END_SRC
** follow symlinks to version controlled files
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks nil)
#+END_SRC
** global keybindings
#+BEGIN_SRC emacs-lisp
  (defun prev-window ()
    "previous window"
    (interactive)
    (other-window -1))

  ;; https://www.emacswiki.org/emacs/UnfillParagraph
  ;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
  (defun unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))

  ;; http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'smarter-move-beginning-of-line)

  (global-set-key (kbd "C-x p") 'prev-window)
  (define-key global-map "\M-Q" 'unfill-paragraph)
  (global-set-key (kbd "C-x x") 'smex)
  (global-set-key (kbd "C-X C-b") 'ibuffer)
  (global-set-key (kbd "C-X g") 'goto-line)
  (global-set-key (kbd "C-;") 'comment-or-uncomment-region)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  ;; This is your old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)

  (global-set-key (kbd "C-<tab>") 'company-complete-common-or-cycle)
#+END_SRC
** whitespace
#+BEGIN_SRC emacs-lisp
  (setq indent-tabs-mode nil)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** backups
https://www.emacswiki.org/emacs/BackupDirectory
#+BEGIN_SRC emacs-lisp
  (setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
   '(("." . "~/.saves"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+END_SRC

* packages
** auctex
Annoying, but seems to be needed since 24.4
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/elpa/auctex-11.89")
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  ;; (setq company-tooltip-align-annotations t)
#+END_SRC
** org
*** misc
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'auto-fill-mode)
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC
*** export
#+BEGIN_SRC emacs-lisp
  (defvar org-export-allow-bind-keywords t)
#+END_SRC
*** babel
**** misc
#+BEGIN_SRC emacs-lisp
  (defvar org-startup-indented t)
  (defvar org-src-fontify-natively t)

  (defun org-babel-invalidate-results ()
    "invalidated all cached babel results"
    (interactive)
    (while (re-search-forward "#\\+RESULTS\\[[[:alnum:]]+\\]" nil t)
      (replace-match "#+RESULTS[]" nil nil)))
#+END_SRC
**** disable evaluation confirmations
#+BEGIN_SRC emacs-lisp
  (defvar org-confirm-babel-evaluate nil)
#+END_SRC
**** inline images
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
  (add-hook 'org-mode-hook 'org-display-inline-images)
#+END_SRC
**** load languages
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/ob-julia")
  (with-eval-after-load "org"
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (haskell . t)
       (julia . t)
       (R . t))))
#+END_SRC

** cider
*** basic configuration
**** Enable eldoc in Clojure buffers
#+BEGIN_SRC emacs-lisp
  (add-hook 'cider-mode-hook #'eldoc-mode)
#+END_SRC
**** Log communication with the nREPL server
#+BEGIN_SRC emacs-lisp
  (setq nrepl-log-messages t)
  (setq nrepl-hide-special-buffers t)
#+END_SRC
**** Prevent the auto-display of the REPL buffer
#+BEGIN_SRC emacs-lisp
  (setq cider-repl-pop-to-buffer-on-connect nil)
#+END_SRC

**** SOT mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'clojure-mode-hook #'abbrev-mode)
  (add-hook 'clojure-mode-hook #'speed-of-thought-mode)
#+END_SRC

**** parens
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/elpa/adjust-parens-3.0")
  (require 'adjust-parens)

  (add-hook 'clojure-mode-hook #'adjust-parens-mode)
  (add-hook 'emacs-lisp-mode-hook #'adjust-parens-mode)

  (add-hook 'clojure-mode-hook #'aggressive-indent-mode)
  ;; (add-hook 'groovy-mode-hook #'aggressive-indent-mode)

  ;; nice, but has caused problems
  ;; (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
#+END_SRC

*** keybindings
#+BEGIN_SRC emacs-lisp
  (defun count-last-sexp ()
	 (interactive)
	 (cider-interactive-eval
           (format "(count %s)"
                   (cider-last-sexp))))

  (defun nth-from-last-sexp (n)
	 (interactive "p")
	 (cider-interactive-eval
           (format "(nth %s %s)"
                   (cider-last-sexp) n)))

  (defun spit-scad-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format
	"(require 'scad-clj.scad)
	 (spit \"eval.scad\" (scad-clj.scad/write-scad %s))"
	(cider-last-sexp))))

  (defun frame-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format
       "(doto (javax.swing.JFrame. \"eval\")
          (.. (getContentPane) (add %s))
          (.pack)
          (.show))"
       (cider-last-sexp))))

  (defun benchmark-last-sexp ()
    (interactive)
    (cider-interactive-eval
      (format "(require 'criterium.core)
               (criterium.core/quick-benchmark %s)"
              (cider-last-sexp))))

  (with-eval-after-load "cider"
    (define-key cider-mode-map (kbd "C-c c") 'count-last-sexp)
    (define-key cider-mode-map (kbd "C-c n") `nth-from-last-sexp)
    (define-key cider-mode-map (kbd "C-c 3") 'spit-scad-last-sexp)
    (define-key cider-mode-map (kbd "C-c f") 'frame-last-sexp)
    (define-key cider-mode-map (kbd "C-c b") 'benchmark-last-sexp))
#+END_SRC
*** misc
#+BEGIN_SRC emacs-lisp
  (defvar clojure-defun-indents '(match resize translate rotate scale mirror))
  ;; (add-hook 'clojure-mode-hook 'typed-clojure-mode)

  ;; (eval-after-load 'flycheck '(flycheck-clojure-setup))
  ;; (eval-after-load 'flycheck
  ;;   '(setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages))

  ;; (add-hook 'clojure-mode-hook (lambda ()
  ;;                                (clj-refactor-mode 1)))
#+END_SRC
** ESS
*** autoload
#+BEGIN_SRC emacs-lisp
  (autoload 'R-mode "ess-site" "Major mode for editing R source.
  See `ess-mode' for more help." t)
  (add-to-list 'auto-mode-alist '("\\.R\\'" . R-mode))
#+END_SRC
*** julia
#+BEGIN_SRC emacs-lisp
  (setq inferior-julia-program-name "/usr/bin/julia")
#+END_SRC
*** R
#+BEGIN_SRC emacs-lisp
  (add-hook 'R-mode-hook 'flycheck-mode)

  ;; From Martin Maechler <maechler at stat.math.ethz.ch>:
  (with-eval-after-load "comint"
    (setq comint-scroll-to-bottom-on-output 'others)   ; not current, dflt is nil
    ;; (setq comint-scroll-show-maximum-output t)      ; I find this too jumpy
    (define-key comint-mode-map [up]
      'comint-previous-matching-input-from-input)
    (define-key comint-mode-map [down]
      'comint-next-matching-input-from-input)
    (define-key comint-mode-map "\C-a" 'comint-bol-or-process-mark))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC
** haskell
#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook 'intero-mode)
  (add-hook 'haskell-mode-hook 'hindent-mode)
#+END_SRC
** rust
#+BEGIN_SRC emacs-lisp
   ;; flycheck
   (with-eval-after-load 'rust-mode
     (require 'cl))
   (add-hook 'rust-mode-hook #'flycheck-rust-setup)
   (add-hook 'rust-mode-hook #'flycheck-mode)

   ;; racer
   (setq racer-rust-src-path "/usr/src/rust/src/")
   (add-hook 'rust-mode-hook #'racer-mode)
   (add-hook 'racer-mode-hook #'eldoc-mode)
#+END_SRC
** scala
#+BEGIN_SRC emacs-lisp
  (add-hook 'ensime-mode-hook 'flycheck-mode)
#+END_SRC
** smartparens
   https://github.com/Fuco1/smartparens/wiki/Example-configuration
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "smartparens-autoloads"
    (require 'smartparens-config)
    (smartparens-global-mode t)
    (smartparens-global-strict-mode t)

    ;; highlights matching pairs
    (show-smartparens-global-mode t)

    ;; keybinding management
    (sp-use-smartparens-bindings)

    ;; pair management
    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

    ;; markdown-mode
    (sp-with-modes '(markdown-mode gfm-mode rst-mode)
      (sp-local-pair "*" "*" :bind "C-*")
      (sp-local-tag "2" "**" "**")
      (sp-local-tag "s" "```scheme" "```")
      (sp-local-tag "<" "<_>" "</_>" :transform 'sp-match-sgml-tags))

    ;; tex-mode latex-mode
    (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
      (sp-local-tag "i" "\"<" "\">"))

    ;; html-mode
    (sp-with-modes '(html-mode sgml-mode)
      (sp-local-pair "<" ">"))

    ;; lisp modes
    (sp-with-modes sp--lisp-modes
      (sp-local-pair "(" nil :bind "C-("))

    (require 'smartparens-latex)
    )
#+END_SRC
#+BEGIN_SRC emacs-lisp
  ;;; keybinding management
  (with-eval-after-load "smartparens-autoloads"
    (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
    (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)

    (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
    (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
    ;; (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
    ;; (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

    (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
    (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
    (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
    (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

    (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
    (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

    (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
    (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

    (define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
    (define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

    (define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
    (define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
    (define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
    (define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

    (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
    (define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
    (define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
    (define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

    (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
    (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
    (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)

    (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
    (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)

    (define-key sp-keymap (kbd "s-t") 'sp-prefix-tag-object)
    (define-key sp-keymap (kbd "s-p") 'sp-prefix-pair-object)
    (define-key sp-keymap (kbd "s-s c") 'sp-convolute-sexp)
    (define-key sp-keymap (kbd "s-s a") 'sp-absorb-sexp)
    (define-key sp-keymap (kbd "s-s e") 'sp-emit-sexp)
    (define-key sp-keymap (kbd "s-s p") 'sp-add-to-previous-sexp)
    (define-key sp-keymap (kbd "s-s n") 'sp-add-to-next-sexp)
    (define-key sp-keymap (kbd "s-s j") 'sp-join-sexp)
    (define-key sp-keymap (kbd "s-s s") 'sp-split-sexp))
#+END_SRC
* miscellaneous
** local
#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~/.emacs.d/local.el")
    (load "~/.emacs.d/local"))
#+END_SRC

** bug fix
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard-manager nil)
#+END_SRC

* customization
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(org-file-apps (quote ((auto-mode . emacs) ("\\.mm\\'" . default) ("\\.x?html?\\'" . default) ("\\.pdf\\'" . "evince %s"))))
   '(org-latex-pdf-process (quote ("pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f"))))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   )
#+END_SRC
